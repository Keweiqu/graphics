// OpenGL Tutorial
// events.c 
/*************************************************************************
This example shows how to accept and handle events.  The user should try 
produce each of the following events: key press, mouse movement, mouse 
button press, mouse button release, reshape window, and expose window.
*************************************************************************/

/*
line is inserted in the order of point - point - line. 
First point inserted during left mouse button down
Second point and line inserted during dragging, or second press()
Two points removed during left mouse up
 */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#ifdef __APPLE__
#include <GLFW/glfw3.h>
#else
#include <GLFW/glfw3.h>
#endif
#include "shapes.h"
#include "hw1.h"

#define TRUE 1
#define FALSE 0
#define POINT_SIZE 8.0
#define WIDTH 500
#define HEIGHT 500
#define SCALE_X_AXIS(x) x / WIDTH * 2 - 1
#define SCALE_Y_AXIS(y) (y / HEIGHT * 2 - 1) * -1
#define DASHED TRUE
#define SOLID FALSE
double mouseX, mouseY;
int shape_mode = LINE;
GLfloat color[] = {0.0, 0.0, 0.0};
int pressed;
int moved;
Point *pressCoordinates;
Point *releaseCoordinates;
GLenum drawMode;
Shape *head, *tail;

int line_available(Shape *tail) {
  return tail->prev->type == POINT &&
    ((Point *)(tail->prev->data))->show &&
    tail->prev->prev->type == POINT &&
    ((Point *)(tail->prev->prev->data))->show;
}

int triangle_available(Shape *tail) {
  return tail->prev->type == LINE && ((Line *)(tail->prev->data))->dashed == TRUE;
}

int has_triangle(Shape* tail) {
  return tail->prev->type == TRIANGLE;
}

void exec_cursor_line() {
  if(pressed){
    if(!moved) {
      if(tail->prev->type != LINE) {
	Point * start_point = (Point *)tail->prev->data;
	Point * end_point = make_point(mouseX, mouseY, color);
	Line * line = make_line(start_point, end_point, color, DASHED);
	insert_shape(tail, make_shape(POINT, end_point));
	insert_shape(tail, make_shape(LINE, line));
      }
      moved = TRUE;
    }else{
      ((Point *)(tail->prev->prev->data))->x = mouseX;
      ((Point *)(tail->prev->prev->data))->y = mouseY;
    }
  }
}

void exec_cursor_triangle(){
  if(!has_triangle(tail)){
    exec_cursor_line();
  }else{
    if(pressed){
      ((Point *)(tail->prev->prev->data))->x = mouseX;
      ((Point *)(tail->prev->prev->data))->y = mouseY;
    }
  }
}

void exec_mouse_down_triangle() {
  if(!triangle_available(tail)){
    exec_mouse_down_line();
  }else{
    if(tail->prev->type == LINE){
      remove_prev(tail);
    }
    exec_mouse_down_point();
    Point* v1 = (Point *)tail->prev->data;
    Point* v2 = (Point *)tail->prev->prev->data;
    Point* v3 = (Point *)tail->prev->prev->prev->data;
    Triangle* triangle = make_triangle(v1, v2, v3, color);
    insert_shape(tail, make_shape(TRIANGLE, triangle));
  }
}

void exec_mouse_down_line() {
  exec_mouse_down_point();
  if(line_available(tail)) {
    Line * line = make_line(
			    (Point *) tail->prev->data,
			    (Point *) tail->prev->prev->data,
			    color,
			    DASHED
			    );
    insert_shape(tail, make_shape(LINE, line));
  }
}

void exec_mouse_down_point(){
  Point * pressCoordinates = make_point(mouseX, mouseY, color);
  insert_shape(tail, make_shape(POINT,pressCoordinates));
  pressed = TRUE;
}

void draw_point(Point* point){
  if(point->show){
    glColor3fv(point->color);
    glBegin(GL_POINTS);
    glVertex2f(point->x, point->y);
    glEnd();
  }
}

void draw_line(Line* line){
  if(line->dashed){
    glEnable(GL_LINE_STIPPLE);
  }else{
    glDisable(GL_LINE_STIPPLE);
  }
  glColor3fv(line->color);
  glBegin(GL_LINES);
  glVertex2f(line->v1->x, line->v1->y);
  glVertex2f(line->v2->x, line->v2->y);
  glEnd();
}

void draw_triangle(Triangle* triangle) {
  glColor3fv(triangle->color);
  glBegin(GL_TRIANGLES);
  glVertex2f(triangle->v1->x, triangle->v1->y);
  glVertex2f(triangle->v2->x, triangle->v2->y);
  glVertex2f(triangle->v3->x, triangle->v3->y);
  glEnd();
}
void draw_shape(Shape* shape) {
  switch(shape->type){
  case POINT:
    draw_point((Point *) shape->data);
    break;
  case LINE:
    draw_line((Line *) shape->data);
    break;
  case TRIANGLE:
    draw_triangle((Triangle *) shape->data);
    break;
  default:
    break;
  }
}

void draw_shapes(Shape* shapes){
  Shape* current = shapes->next;
  while(current->type != -1) {
    draw_shape(current);
    current = current->next;
  }
}
void init() {
  // Set the clear color to white
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glColor3fv(color);
  glPointSize(POINT_SIZE);
  glLineStipple(1, 0x3F07);
}

void entry(GLFWwindow* window, int entered) {
  printf("Got an Window Entry Event:");
  printf(":\t %s\n", entered?"entered":"left");
 }

void reshape(GLFWwindow *w, int width, int height){  
  printf("Got a Reshape Event");
  printf(":\t width = %d height = %d\n", width, height);

  // Set the new viewport size
  glViewport(0, 0, width, height);
}

void keyboard(GLFWwindow *w, int key, int scancode, int action, int mods) {
  printf("Got a Keyboard Event: ");
  printf(" %d, ", key);
  if(action == GLFW_PRESS) {
    switch(key) {
    case 'R':
      color[0] = 1.0;
      color[1] = 0.0;
      color[2] = 0.0;
      break;
    case GLFW_KEY_F1:
      shape_mode = LINE;
      break;
    case GLFW_KEY_F2:
      shape_mode = TRIANGLE;
      break;
    default:
      break;
    }
  }
  switch(action) {
  case GLFW_PRESS :
    printf("pressed,\t");
    break;
  case GLFW_RELEASE :
    printf("released,\t");
    break;
  case GLFW_REPEAT :
    printf("repeated,\t");
    break;
  default :
    printf("shouldn't happen\t");
    break;
  }  

  switch(mods) {
  case GLFW_MOD_SHIFT :
    printf("shift held\n");
    break;
  case GLFW_MOD_ALT :
    printf("alt held\n");
    break;
  case GLFW_MOD_CONTROL :
    printf("ctrl held\n");
    break;
  default :
    printf("no modifiers.\n");
    break;
  }

  switch(key) {
  case GLFW_KEY_ESCAPE :
  case 'q' :
  case 'Q':
    glfwSetWindowShouldClose(w, GL_TRUE);
    break;
  default:
    break;
  }
}


void mouse(GLFWwindow* window, int button, int action, int mods) {
  double xpos, ypos;
  glfwGetCursorPos(window, &xpos, &ypos);
  switch (button) {
  case GLFW_MOUSE_BUTTON_LEFT:
    mouseX = SCALE_X_AXIS(xpos);
    mouseY = SCALE_Y_AXIS(ypos);
    if(action == GLFW_PRESS) {
      printf("left mouse down\n");
      switch(shape_mode){
      case LINE:
	exec_mouse_down_line();
	break; // LINE
      case TRIANGLE:
	exec_mouse_down_triangle();
	break;
      default:
	break;
      }
    } else {
      pressed = FALSE;
      switch(shape_mode) {
      case LINE:
	if(tail->prev->type == LINE){
	  ((Line *) tail->prev->data)->dashed = FALSE;
	  ((Point *)(tail->prev->prev->data))->show = FALSE;
	  ((Point *)(tail->prev->prev->prev->data))->show = FALSE;
	}
	moved = FALSE;
	break;
      case TRIANGLE:
	moved = FALSE;
	if(has_triangle(tail)){
	  ((Point *) tail->prev->prev->data)->show = FALSE;
	  ((Point *) tail->prev->prev->prev->data)->show = FALSE;
	  ((Point *) tail->prev->prev->prev->prev->data)->show = FALSE;
	}
	break;
      default:
	break;
      }
    }// MOUSE_BUTTON_LFET
    break;
  default : //default for NOUSE_BUTTON 
    printf("none\n");
    break;
  }
}

void cursor(GLFWwindow* window, double xpos, double ypos) {
  printf("curser\n");
  mouseX = SCALE_X_AXIS(xpos);
  mouseY = SCALE_Y_AXIS(ypos);
  switch(shape_mode){
  case LINE:
    exec_cursor_line();
    break;
  case TRIANGLE:
    exec_cursor_triangle();
  default:
    break;
  }
}

int main(int argc, char **argv) {
  head = make_shape(-1, 0);
  tail = make_shape(-1, 0);
  head->next = tail;
  tail->prev = head;
  GLFWwindow* window;
  
  // Initialize the library 
  if (!glfwInit())
    exit(EXIT_FAILURE);

  // Create a window and its OpenGL context 
  window = glfwCreateWindow(WIDTH, HEIGHT, "Hello GL!", NULL, NULL);
  if (!window){
    glfwTerminate();
    exit(EXIT_FAILURE);
  }

  glfwSetWindowPos(window, 100, 100);
  // Make the window's context current 
  glfwMakeContextCurrent(window);

  // Assign entry() to be the function called whenever
  // a window entry event occurs
  glfwSetCursorEnterCallback(window, entry);

 // Assign reshape() to be the function called whenever 
 // a reshape event occurs
  glfwSetWindowSizeCallback(window, reshape);

  // Assign keyboard() to be the function called whenever
  // a key is pressed or released
  glfwSetKeyCallback(window, keyboard);

  // Assign mouse() to be the function called whenever
  // a mouse button is pressed or released
  glfwSetMouseButtonCallback(window, mouse);

  // Assign cursor() to be the function called whenever
  // a cursor moves
  glfwSetCursorPosCallback(window, cursor);

  init();
  // Loop until the user closes the window 
  while (!glfwWindowShouldClose(window)) {
    // clear to background color
    glClear(GL_COLOR_BUFFER_BIT);
    
    draw_shapes(head);
    
    // Swap front and back buffers 
    glfwSwapBuffers(window);

    // Poll for and process events 
    glfwPollEvents();
  }

  glfwTerminate();
  exit(EXIT_SUCCESS);
}
